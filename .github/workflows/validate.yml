name: Validate Framework

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read

jobs:
  validate-yaml:
    name: Validate YAML
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: pip install pyyaml

      - name: Validate CONFIG.yaml
        run: |
          python3 - <<'PY'
          import yaml

          with open("CONFIG.yaml", "r", encoding="utf-8") as file:
              yaml.safe_load(file)

          print("CONFIG.yaml: OK")
          PY

      - name: Validate all YAML files
        run: |
          EXIT_CODE=0
          while IFS= read -r file; do
            if python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
              echo "OK: $file"
            else
              echo "FAIL: $file"
              EXIT_CODE=1
            fi
          done < <(find . -name "*.yaml" -o -name "*.yml" | grep -v '.github/' | grep -v 'node_modules/')
          exit $EXIT_CODE

  validate-markdown:
    name: Validate Markdown
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for broken internal links and cross-file references
        run: |
          python3 - <<'PY'
          import re
          import sys
          from pathlib import Path

          repo = Path(".").resolve()

          md_files = [
            p for p in repo.rglob("*.md")
            if ".git" not in p.parts
            and "node_modules" not in p.parts
            and "_TEMPLATE" not in p.name
          ]

          inline_link_pattern = re.compile(r"\[[^\]]*\]\(([^)]+)\)")
          reference_use_pattern = re.compile(r"\[[^\]]+\]\[([^\]]+)\]")
          reference_def_pattern = re.compile(r"^\s*\[([^\]]+)\]:\s*(\S+)", re.MULTILINE)
          heading_pattern = re.compile(r"^#{1,6}\s+(.+?)\s*$", re.MULTILINE)

          def normalize_anchor(text: str) -> str:
            value = text.strip().lower()
            value = re.sub(r"[`*_~\[\](){}.!?,:;\"'\\\\]", "", value)
            value = re.sub(r"\s+", "-", value)
            value = re.sub(r"-+", "-", value).strip("-")
            return value

          def is_external(target: str) -> bool:
            lower = target.lower()
            return (
              lower.startswith("http://")
              or lower.startswith("https://")
              or lower.startswith("mailto:")
              or lower.startswith("tel:")
              or lower.startswith("ftp://")
            )

          def parse_target(raw: str):
            cleaned = raw.strip()
            if cleaned.startswith("<") and cleaned.endswith(">"):
              cleaned = cleaned[1:-1].strip()
            if " " in cleaned:
              cleaned = cleaned.split(" ", 1)[0]
            if "{{" in cleaned:
              return None, None, True
            if is_external(cleaned):
              return None, None, True
            if cleaned.startswith("#"):
              return "", cleaned[1:], False
            path_part, anchor = (cleaned.split("#", 1) + [""])[:2] if "#" in cleaned else (cleaned, "")
            return path_part, anchor, False

          def resolve_path(source: Path, path_part: str) -> Path:
            if path_part.startswith("/"):
              target = repo / path_part.lstrip("/")
            else:
              target = (source.parent / path_part).resolve()
            return target

          heading_cache = {}

          def get_headings(md_file: Path):
            if md_file in heading_cache:
              return heading_cache[md_file]
            text = md_file.read_text(encoding="utf-8", errors="ignore")
            anchors = {normalize_anchor(m.group(1)) for m in heading_pattern.finditer(text)}
            heading_cache[md_file] = anchors
            return anchors

          broken = []

          for md_file in md_files:
            text = md_file.read_text(encoding="utf-8", errors="ignore")

            ref_defs = {
              key.strip().lower(): value.strip()
              for key, value in reference_def_pattern.findall(text)
            }

            candidates = [match.group(1).strip() for match in inline_link_pattern.finditer(text)]

            for ref_key in reference_use_pattern.findall(text):
              ref_target = ref_defs.get(ref_key.strip().lower())
              if ref_target:
                candidates.append(ref_target)

            for candidate in candidates:
              path_part, anchor, skip = parse_target(candidate)
              if skip:
                continue

              target_file = md_file if path_part == "" else resolve_path(md_file, path_part)

              try:
                target_file.relative_to(repo)
              except ValueError:
                broken.append((md_file, candidate, "target escapes repository"))
                continue

              if not target_file.exists():
                broken.append((md_file, candidate, "target does not exist"))
                continue

              if anchor:
                if target_file.suffix.lower() == ".md":
                  anchors = get_headings(target_file)
                  normalized = normalize_anchor(anchor)
                  if normalized not in anchors:
                    broken.append((md_file, candidate, f"missing anchor #{anchor}"))

          if broken:
            print("Broken markdown links found:")
            for src, link, reason in broken:
              print(f"- {src.relative_to(repo)} -> {link} ({reason})")
            print(f"\nTotal broken links: {len(broken)}")
            sys.exit(1)

          print(f"Checked {len(md_files)} markdown files: all internal links OK")
          PY

  validate-placeholders:
    name: Check Placeholders
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Ensure templates use placeholders correctly
        run: |
          echo "Checking placeholder consistency..."
          # Non-template files should not have unfilled placeholders
          # (except CONFIG.yaml which defines them)
          VIOLATIONS=$(grep -rn '{{[A-Z_]*}}' --include="*.md" . \
            | grep -v '_TEMPLATE' \
            | grep -v 'CONFIG.yaml' \
            | grep -v 'CONTRIBUTING.md' \
            | grep -v 'CUSTOMIZATION-GUIDE.md' \
            | grep -v 'AGENT-BOOTSTRAP-PROMPT.md' \
            | grep -v 'OPERATING-MODEL.md' \
            | grep -v '.github/' \
            || true)
          if [ -n "$VIOLATIONS" ]; then
            echo "Found unfilled placeholders in non-template files:"
            echo "$VIOLATIONS"
            echo ""
            echo "Either fill these from CONFIG.yaml or convert the file to a _TEMPLATE."
            # Warning only â€” don't fail the build
          fi
          echo "Placeholder check complete"

  validate-structure:
    name: Validate Structure
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check required files exist
        run: |
          REQUIRED_FILES=(
            "README.md"
            "AGENTS.md"
            "CONFIG.yaml"
            "COMPANY.md"
            "CONTRIBUTING.md"
            "OPERATING-MODEL.md"
            "CODEOWNERS"
            "LICENSE"
            "org/README.md"
            "process/README.md"
            "work/README.md"
          )
          MISSING=0
          for f in "${REQUIRED_FILES[@]}"; do
            if [[ -f "$f" ]]; then
              echo "OK: $f"
            else
              echo "MISSING: $f"
              MISSING=$((MISSING + 1))
            fi
          done
          if [ $MISSING -gt 0 ]; then
            echo "$MISSING required file(s) missing"
            exit 1
          fi

      - name: Check layer structure
        run: |
          for layer in 0-steering 1-strategy 2-orchestration 3-execution 4-quality; do
            if [[ ! -f "org/$layer/AGENT.md" ]]; then
              echo "MISSING: org/$layer/AGENT.md"
              exit 1
            fi
            echo "OK: org/$layer/AGENT.md"
          done

      - name: Check process loops
        run: |
          for loop in 1-discover 2-build 3-ship 4-operate; do
            for file in AGENT.md GUIDE.md; do
              if [[ ! -f "process/$loop/$file" ]]; then
                echo "MISSING: process/$loop/$file"
                exit 1
              fi
              echo "OK: process/$loop/$file"
            done
          done
